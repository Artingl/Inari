#pragma once

#include <kernel/include/C/typedefs.h>

#define ATA_PIO_PRIMARY_IO(v)                          (v+0x1F0)
#define ATA_PIO_PRIMARY_CONTROL(v)                     (v+0x3F6)

#define ATA_PIO_SECONDARY_IO(v)                        (v+0x170)
#define ATA_PIO_SECONDARY_CONTROL(v)                   (v+0x376)

// Offset from "I/O" base 
#define ATA_PIO_DATA                        0x00        // R/W 	Data Register 	                  Read/Write PIO data bytes 	                                         16-bit / 16-bit
#define ATA_PIO_ERR                         0x01        // R 	Error Register 	                  Used to retrieve any error generated by the last ATA command executed. 8-bit / 16-bit
#define ATA_PIO_FEAT                        0x01        // W 	Features Register 	              Used to control command specific interface features. 	                 8-bit / 16-bit
#define ATA_PIO_SECTOR_CNT                  0x02        // R/W 	Sector Count Register 	          Number of sectors to read/write (0 is a special value). 	             8-bit / 16-bit
#define ATA_PIO_SECTOR_NUM                  0x03        // R/W 	Sector Number Register (LBAlo) 	  This is CHS / LBA28 / LBA48 specific. 	                             8-bit / 16-bit
#define ATA_PIO_CYLINDER_LOW                0x04        // R/W 	Cylinder Low Register / (LBAmid)  Partial Disk Sector address. 	                                         8-bit / 16-bit
#define ATA_PIO_CYLINDER_HIGH               0x05        // R/W 	Cylinder High Register / (LBAhi)  Partial Disk Sector address. 	                                         8-bit / 16-bit
#define ATA_PIO_DRIVE                       0x06        // R/W 	Drive / Head Register 	          Used to select a drive and/or head. Supports extra address/flag bits.  8-bit / 8-bit
#define ATA_PIO_STATUS                      0x07        // R 	Status Register 	              Used to read the current status. 	                                     8-bit / 8-bit
#define ATA_PIO_COMMAND                     0x07        // W 	Command Register 	              Used to send ATA commands to the device. 	                             8-bit / 8-bit 

// Offset from "Control" base 
#define ATA_PIO_ALTERNATE_STATUS            0x00        // R 	Alternate Status Register 	      A duplicate of the Status Register which does not affect interrupts. 	 8-bit / 8-bit
#define ATA_PIO_ALTERNATE_DEVICE_CONTROL    0x00        // W 	Device Control Register 	      Used to reset the bus or enable/disable interrupts. 	                 8-bit / 8-bit
#define ATA_PIO_ALTERNATE_DRIVE_ADDRESS     0x01        // R 	Drive Address Register 	          Provides drive select and head select information. 	                 8-bit / 8-bit 

// Error Register
#define AMNF                                (1 << 0)    //    	Address mark not found.
#define TKZNF                               (1 << 1)    //    	Track zero not found.
#define ABRT                                (1 << 2)    //    	Aborted command.
#define MCR                                 (1 << 3)    //    	Media change request.
#define IDNF                                (1 << 4)    //    	ID not found.
#define MC                                  (1 << 5)    //    	Media changed.
#define UNC                                 (1 << 6)    //    	Uncorrectable data error.
#define BBK                                 (1 << 7)    //    	Bad Block detected. 

// Drive / Head Register (I/O base + 6)
#define DRV                                 (1 << 4)    //    	Selects the drive number.
#define LBA                                 (1 << 6)    //    	Uses CHS addressing if clear or LBA addressing if set.

// Status Register (I/O base + 7)
#define ERR                                 (1 << 0)    //       Indicates an error occurred. Send a new command to clear it (or nuke it with a Software Reset).
#define IDX                                 (1 << 1)    //       Index. Always set to zero.
#define CORR                                (1 << 2)    //       Corrected data. Always set to zero.
#define DRQ                                 (1 << 3)    //       Set when the drive has PIO data to transfer, or is ready to accept PIO data.
#define SRV                                 (1 << 4)    //       Overlapped Mode Service Request.
#define DF                                  (1 << 5)    //       Drive Fault Error (does not set ERR).
#define RDY                                 (1 << 6)    //       Bit is clear when drive is spun down, or after an error. Set otherwise.
#define BSY                                 (1 << 7)    //       Indicates the drive is preparing to send/receive data (wait for it to clear). In case of 'hang' (it never clears), do a software reset. 

// Device Control Register (Control base + 0)
#define nIEN                                (1 << 1)    //       Set this to stop the current device from sending interrupts.
#define SRST                                (1 << 2)    //       Set, then clear (after 5us), this to do a "Software Reset" on all ATA drives on a bus, if one is misbehaving.
#define HOB                                 (1 << 7)    //       Set this to read back the High Order Byte of the last LBA48 value sent to an IO port. 

#define DS0                                 (1 << 0)    //    	Drive 0 select. Clears when drive 0 selected.
#define DS1                                 (1 << 1)    //    	Drive 1 select. Clears when drive 1 selected.
#define HS0                                 (1 << 2)    //    	One's compliment representation of the currently selected head.
#define HS1                                 (1 << 3)    //    	One's compliment representation of the currently selected head.
#define HS2                                 (1 << 4)    //    	One's compliment representation of the currently selected head.
#define HS3                                 (1 << 5)    //    	One's compliment representation of the currently selected head.
#define WTG                                 (1 << 6)    //    	Write gate; goes low while writing to the drive is in progress.

#define ATA_PIO_PRIMARY_IRQ 14
#define ATA_PIO_SECONDARY_IRQ 15


#define ATA_MASTER_DRIVE 0xa0
#define ATA_SLAVE_DRIVE 0xB0

enum {
    ATA_PIO_DRIVE_NOT_FOUND = 1,
    ATA_PIO_NOT_ATA_DRIVE = 2,
    ATA_PIO_ERROR = 3,
};

#define ATA_PIO_DRIVE_ID(drive_id, controller) (drive_id == ATA_MASTER_DRIVE ? 0 : 1 + (controller * 2))

struct ata_pio_drive
{
    bool present;
    uint8_t drive_id;
    uint8_t controller;
    char *payload[512];
};

int ata_pio_init();
int ata_pio_identify(uint8_t drive);
void ata_pio_read28(struct ata_pio_drive *drive, size_t sector, uint16_t *buffer);
